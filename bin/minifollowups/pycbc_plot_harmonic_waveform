#!/bin/env python
# Copyright (C) 2025 Rahul Dhurkunde
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

""" Plot the single detector trigger timeseries """
import argparse
import logging
import sys
import h5py
import matplotlib
matplotlib.use('Agg')
import pylab
import numpy

from pycbc import init_logging, add_common_pycbc_options
import pycbc.results
from pycbc.types import MultiDetOptionAction
from pycbc.types import FrequencySeries
from pycbc.events import ranking
from pycbc.events import select_segments_by_definer
from pycbc.filter.matchedfilter import sigma
from pycbc.io import HFile, SingleDetTriggers
from pycbc.waveform.bank import PhenomXPTemplate, compute_beta
from pycbc.strain import StrainSegments
import pycbc.waveform.bank as bank

class template_params:
    def __init__(self, bank, x):
        for key in bank.keys():
            setattr(self, key, bank[key][x])

def _make_waveform_from_precessing_harmonics(
    phenom_object, harmonic_dict, amplitudes_dict=None, phases_dict=None
):
    #Compute the antenna pattern functions
    phase = phenom_object.orb_phase
    psi = phenom_object.psi
    thetaJN = phenom_object.thetaJN
    alpha0 = phenom_object.alpha0
    beta = phenom_object.beta
    dpsi = bank._dpsi(thetaJN, alpha0, beta)
    fp = numpy.cos(2 * (psi - dpsi))
    fc = -1. * numpy.sin(2 * (psi - dpsi))

    A = amplitudes_dict
    h_app = None
    for k, harm in harmonic_dict.items():
        if h_app is not None:
            h_app += A[k] * harm * numpy.exp(1j * phases_dict[k])
        else:
            h_app = A[k] * harm * numpy.exp(1j * phases_dict[k])
    return h_app


def obtain_trigger_amp_phase(trigs, special_idx):
    norm_snr = 0.0
    #Get the total SNR
    for i in range(5):
        key = 'snr_comp_{}'.format(i+1)
        norm_snr += trigs.trigs[key][special_idx]**2
    norm_snr = numpy.sqrt(norm_snr)

    amplitudes_dict = {}
    phases_dict = {}
    
    for i in range(5):
        key = 'snr_comp_{}'.format(i+1)
        phase_key = 'coa_phase_comp_{}'.format(i+1)
        amplitudes_dict[i] = trigs.trigs[key][special_idx]/norm_snr
        phases_dict[i] = trigs.trigs[phase_key][special_idx]
    return amplitudes_dict, phases_dict


def select_segments(fname, anal_name, data_name, ifo, time, pad_data):
    anal_segs = select_segments_by_definer(fname, anal_name, ifo)
    data_segs = select_segments_by_definer(fname, data_name, ifo)

    # Anal segs should be disjoint, so first find the seg containing time
    s = numpy.array([t[0] for t in anal_segs])
    e = numpy.array([t[1] for t in anal_segs])
    #ensure sorted
    sorting = s.argsort()
    s = s[sorting]
    e = e[sorting]
    idx = numpy.searchsorted(s, time) - 1
    anal_time = (s[idx], e[idx])

    # Now need to find the corresponding data_seg. This could be complicated
    # as in edge cases the anal_time tuple could be completely contained within
    # *two* data blocks (think analysis chunk slightly longer than minimum).
    # We need to choose the *right* block to reproduce what the search did.

    s2 = numpy.array([t[0] for t in data_segs])
    e2 = numpy.array([t[1] for t in data_segs])
    lgc = (s2 < time) & (e2 > time)
    s2 = s2[lgc]
    e2 = e2[lgc]
    if len(s2) == 0:
        err_msg = "Cannot find a data segment within %s" %(str(time))
        raise ValueError(err_msg)
    if len(s2) == 1:
        data_time = (s2[0], e2[0])
    if len(s2) > 1:
        # The tricksy case. The corresponding data segment should have the
        # largest overlap with anal_time
        overlap = None
        for start, end in zip(s2, e2):
            if start + pad_data > anal_time[0] or end - pad_data < anal_time[1]:
                # The analysis time must lie within the data time, otherwise
                # this clearly is not the right data segment!
                continue

            curr_nonoverlap = anal_time[0] - start
            curr_nonoverlap += end - anal_time[1]
            if (overlap is None) or (curr_nonoverlap < overlap):
                overlap = curr_nonoverlap
                data_time = (start, end)
        if overlap is None:
            raise ValueError()

    return anal_time, data_time


def compute_harmonic_waveform(trigs, special_idx, ifo, merge_psd_file,
                              sample_rate, segment_length, f_lower,
                              segs_file_name, data_segment_name,
                              analysed_segment_name, segment_start_pad,
                              segment_end_pad, pad_data):
    bad_tempid = trigs.trigs['template_id'][special_idx]
    end_time = trigs.trigs['end_time'][special_idx]

    psd_fp = h5py.File(merge_psd_file, 'r')
    psd_fp = psd_fp[ifo]
    analysed_time, data_time = select_segments(
        segs_file_name,
        analysed_segment_name,
        data_segment_name,
        ifo,
        end_time,
        pad_data=pad_data,
    )

    class DummyStrain():
        pass

    dummy_str = DummyStrain()
    dummy_str.sample_rate = sample_rate
    dummy_str.delta_t = 1./sample_rate
    dummy_str.start_time = data_time[0]
    dummy_str.end_time = data_time[1]
    dummy_str.duration = dummy_str.end_time - dummy_str.start_time

    str_segs = StrainSegments(
        dummy_str,
        segment_length=segment_length,
        segment_start_pad = segment_start_pad,
        segment_end_pad = segment_end_pad,
        trigger_start = analysed_time[0],
        trigger_end = analysed_time[1],
        allow_zero_padding = True
    )

    for seg_slice, ana in zip(str_segs.segment_slices, str_segs.analyze_slices):
        st = (seg_slice.start + ana.start)/sample_rate + data_time[0]
        et = (seg_slice.start+ana.stop)/sample_rate + data_time[0]
        if st < end_time < et:
            analysed_start = st
            analysed_end = et
            break
    else:
        raise ValueError("Didn't find a segment")

    psd_idx = None
    overlap = 0
    for idx in range(len(psd_fp['start_time'])):
        st = psd_fp['start_time'][idx]
        et = psd_fp['end_time'][idx]
        if st < analysed_end and analysed_start < et:
            curr_overlap = min(et, analysed_end) - max(st, analysed_start)
            if curr_overlap > overlap:
                psd_idx = idx
                overlap = curr_overlap
    if psd_idx is None:
        err_msg = "I couldn't find an overlapping PSD in the file!"
        err_msg += f" Covering time {end_time}."

    psd_data = psd_fp[f'psds/{psd_idx}']
    df = psd_data.attrs['delta_f']
    epoch = psd_data.attrs['epoch']
    data = psd_data[:]
    psd = FrequencySeries(
        data,
        delta_f=df,
        epoch=epoch,
        dtype=data.dtype,
        copy=False
    )
    
    amplitudes_dict, phases_dict = obtain_trigger_amp_phase(trigs, special_idx)

    #Create the template PhenomObject
    #### Hard-coded stuff change!! Get it from the triggers SOMEHOW?
    flen = int(sample_rate * segment_length/2+1)
    ncomp = trigs.bank['num_comps'][bad_tempid]
    # Hardcoded max numcomps for now:
    if ncomp > 3:
        ncomp = 3

    phenom_object = PhenomXPTemplate(params, sample_rate, f_lower)

    harmonics = phenom_object.get_whitened_normalized_comps(
        1.0/segment_length,
        psd,
        num_comps=ncomp,
    )

    #reverse_flag = trigs.bank['reverse_flag'][bad_tempid]
    logging.info("Template id: {}, mass1: {}, mass2: {}, SNR: {}, ncomp: {}".format(bad_tempid, 
                                                                        trigs.bank['mass1'][bad_tempid],
                                                                        trigs.bank['mass2'][bad_tempid],
                                                                        trigs.trigs['snr'][special_idx],
                                                                        ncomp) )

    # FIXME: Can we remove harmonics_dict and just use harmonics?
    harmonics_dict = {}
    for i in range(ncomp):
        harmonics_dict[i] = harmonics[i]

    p_det = _make_waveform_from_precessing_harmonics(phenom_object, harmonics_dict, amplitudes_dict, phases_dict)

    # Apply 2s time-shift to wrap the merger away from the endfor plotting
    pt_det = p_det.to_timeseries()
    shifted_t = pt_det.cyclic_time_shift(-2)

    #Amplify the template
    amp_factor = sigma(harmonics_dict[0], low_frequency_cutoff=f_lower)
    shifted_t /= amp_factor

    harmonics = []
    for i in range(ncomp):
        harm_temp = harmonics_dict[i].to_timeseries()
        harm_temp = harm_temp.cyclic_time_shift(-2)
        harm_temp /= amp_factor
        harmonics.append(harm_temp)

    return shifted_t, ncomp, harmonics
    

parser = argparse.ArgumentParser()
add_common_pycbc_options(parser)
#parser.add_argument('--verbose')
parser.add_argument('--single-trigger-files', nargs='+',
    action=MultiDetOptionAction, metavar="IFO:FILE",
    required=True,
    help="The HDF format single detector merged trigger files, in "
         "multi-ifo argument format, H1:file1.hdf L1:file2.hdf, etc")
parser.add_argument('--bank-file',
    required=True,
    help="The bank file in HDF format")
parser.add_argument('--veto-file',
    help="The veto file in XML format")
parser.add_argument('--special-trigger-ids', nargs='+', type=int,
    action=MultiDetOptionAction, metavar="IFO:trigger_id",required=True,
    help="The set of special trigger ids to plot a star at")
parser.add_argument('--plot-type',
    choices=ranking.sngls_ranking_function_dict, default='snr',
    help="Which single-detector ranking statistic to plot.")
parser.add_argument('--merge-psd-files', nargs='+',
    action=MultiDetOptionAction, metavar="IFO:FILE",
    help="Location of the MERGE_PSD output fiel to get the PSD from.",
    required=True,
)
parser.add_argument('--sample-rate', type=float, required=True,
    help="Sample rate of the waveform",
)
parser.add_argument('--segment-length', type=float, required=True,
    help="Length of waveform to generate (delta_f = 1 / segment_length)",
)
parser.add_argument('--f-lower', type=float, required=True,
    help="Lower frequency for waveform generation",
)
# These options can be used to identify start/end times
parser.add_argument("--inspiral-segments", required=True,
        help="XML file containing the inspiral analysis segments. "
             "Only used with the --statmap-file option")
parser.add_argument("--data-read-name", required=True,
        help="name of the segmentlist containing the data read in by each job "
             "from the inspiral segment file")
parser.add_argument("--data-analyzed-name", required=True,
        help="name of the segmentlist containing the data analysed by each job "
             "from the inspiral segment file")
parser.add_argument('--segment-start-pad', type=int, required=True)
parser.add_argument("--segment-end-pad", type=int, required=True)
parser.add_argument("--pad-data", default=8, type=int)

parser.add_argument('--output-file')

args = parser.parse_args()
init_logging(args.verbose)

fig = pylab.figure()

bankf = h5py.File(args.bank_file, 'r')

fig, axs = pylab.subplots(len(args.single_trigger_files), 1, figsize=(14,8))
if len(args.single_trigger_files) == 1:
    axs = [axs]
axs_count=0

for ifo in args.single_trigger_files.keys():
    logging.info("Getting %s triggers", ifo)

    trigs = SingleDetTriggers(
        args.single_trigger_files[ifo],
        ifo,
        bank_file=args.bank_file,
        veto_file=args.veto_file,
    )

    special_idx = args.special_trigger_ids[ifo]
    logging.info("Special idx %d for ifo %s", args.special_trigger_ids[ifo], ifo)
    
    params = template_params(bankf, trigs.trigs['template_id'][special_idx])

    shifted_t, ncomp, harmonics = compute_harmonic_waveform(trigs, special_idx, ifo, args.merge_psd_files[ifo], args.sample_rate, args.segment_length, args.f_lower, args.inspiral_segments, args.data_read_name, args.data_analyzed_name, args.segment_start_pad, args.segment_end_pad, args.pad_data)

    ###Zoom-in automatically. Again a crappy way! Improve it !!
    threshold = 1e-2  # or something data-specific
    nonzero_indices = numpy.where(numpy.abs(shifted_t) > threshold)[0]
    i_min, i_max = nonzero_indices[0], nonzero_indices[-1]

    axs[axs_count].plot(shifted_t.sample_times[i_min:i_max], shifted_t[i_min:i_max], label="Full waveform")
    for idx, harm in enumerate(harmonics):
        axs[axs_count].plot(harm.sample_times[i_min:i_max], harm[i_min:i_max], linestyle=':', label=f"Harmonic {idx+1}")
    axs[axs_count].set_title('{}: {}-harmonic plot'.format(ifo, ncomp))
    axs[axs_count].set_xlabel('time (s)')
    axs[axs_count].set_ylabel("Scaled $h(t)$")
    max_val = abs(shifted_t.data).argmax()
    max_time = shifted_t.sample_times[max_val]
    axs[axs_count].set_xlim([-0.7, 0.2])
    axs[axs_count].legend()
    axs[axs_count].grid()
    axs_count += 1

logging.info("Saving figure")
pycbc.results.save_fig_with_metadata(fig, args.output_file,
            cmd = ' '.join(sys.argv),
            title = '{}-harmonic plot'.format(ncomp),
            caption = '', fig_kwds={'dpi': 300}
         )
logging.info("Done!")
